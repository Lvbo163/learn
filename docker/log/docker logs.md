# Docker logs

<!-- TOC -->

- [目录](#docker-logs)
    - [一、 docker logs 实现剖析](#一-docker-logs-实现剖析)
        - [1. Docker 容器应用如何产生日志？](#1-docker-容器应用如何产生日志)
        - [2. Docker 容器应用的日志实现](#2-docker-容器应用的日志实现)
        - [3. 用户如何查看容器日志？](#3-用户如何查看容器日志)
    - [二、docker exec 与容器日志](#二docker-exec-与容器日志)
        - [1. 容器进程树与 docker exec](#1-容器进程树与-docker-exec)
        - [2.docker exec 原理与容器日志](#2docker-exec-原理与容器日志)
    - [三、Docker 容器日志的那些事儿](#三docker-容器日志的那些事儿)
        - [1. 传统应用的日志](#1-传统应用的日志)
        - [2. Docker 时代的日志](#2-docker-时代的日志)
        - [3. 获取 Docker 容器持久化日志](#3-获取-docker-容器持久化日志)

<!-- /TOC -->

## 一、 docker logs 实现剖析

[原文地址](http://guide.daocloud.io/dcs/docker-logs-9153967.html)

Docker 完全可以轻易构建用户的应用，即为 build；

Docker 还可以将应用快速分发，即为 ship；

最后，Docker 依然有能力秒级启动应用，即为 run。

Build，Ship，Run，简单的3步，分分钟为 DevOps 创建了管理应用生命周期的捷径。

应用是运行起来了，应用运行后，运行状态相信是工程师最关心的点。这一点，Docker 如何帮工程师排忧解难呢？

想知道应用是否仍在运行？docker ps  会告诉您。

想获知应用的资源使用情况如何？docker stats  为您呈现。

想了解应用的运行日志？docker logs  绝对是您最好的选择。

如今，Docker 容器应用的日志分析，已经是一个获悉应用运行逻辑的状态，以及分析应用运行性能的不二法宝。

基于 Docker 容器的日志，已然有很多人在做；那大家是否了解 Docker 容器的日志是怎么来的呢？如果大家还不清楚 Docker 日志的实现原理，那么本文可以带您窥探 docker logs 的究竟。

### 1. Docker 容器应用如何产生日志？
大家可以试想一下，如果没有 Docker，您的应用如何打印日志？普遍情况有以下两种：
- 第一，向标准输出（stdout）中打印日志；
- 第二，设置日志文件 app.log （或其它文件名），向此文件中打印日志。
Docker 从诞生伊始，就从未对用户应用做出标准性规范，日志也不例外，从未有过限制。既然如此，Docker 容器应用的日志也不外乎以上两种。第二种很好理解，依然往容器中某个日志文件打印；然而第一种，应用通过标准输出（stdout）的方式打印日志，该如何呈现给用户？

### 2. Docker 容器应用的日志实现
对于日志文件，Docker 不可能也不应该深入应用内部逻辑，截获并接管日志文件内容，这只会破坏 Docker 的通用性。但是对于 Docker 容器内应用的标准输出，Docker 则是做了工作的。具体实现，可以参考下图：

![日志实现](http://7xi8kv.com5.z0.glb.qiniucdn.com/docker%20logs.png)

假设 application 是 Docker 容器内部运行的应用，那么对于应用的第一部分标准输出（stdout）日志，Docker Daemon 在运行这个容器时就会创建一个协程（goroutine），负责标准输出日志。

由于此 goroutine 绑定了整个容器内所有进程的标准输出文件描述符，因此容器内应用的所有标准输出日志，都会被 goroutine 接收。goroutine 接收到容器的标准输出内容时，立即将这部分内容，写入与此容器一一对应的日志文件中，日志文件位于 /var/lib/docker/containers/<container_id> ，文件名为 <container_id>-json.log 。

至此，关于容器内应用的所有标准输出日志信息，已经全部被 Docker Daemon 接管，并重定向到与容器一一对应的日志文件中。

### 3. 用户如何查看容器日志？
日志总是需要被用户查看的，Docker 则通过 docker logs  命令向用户提供日志接口。docker logs  实现原理的本质均基于与容器一一对应的 <container-id>-json.log ，除了 docker logs -f  命令。

以下简要介绍 docker logs  命令下各参数的含义：

- 无参数：直接显示容器的所有日志信息
- tail：从尾部开始按需显示容器日志
- since：从某个时间开始显示容器日志
- timestamp：显示容器日志时显示日志时间戳
- f：将当前时间点，容器日志文件 <container-id>-json.log 中的日志信息全部打印；此时间点之后所有的日志信息与日志文件无关，直接接收goroutine 往日志文件中写的文件描述符，并显示
总而言之，Docker 容器日志的处理并不会很复杂。此文阅完，日志的来龙去脉，一清二楚。

当然，您也可以做两个实验检验以上内容：
- Experiement 1：通过 Docker 运行一个应用，日志会从标准输出打印日志，然后通过 docker logs  查看日志。
- Experiement 2：运行一个 Docker 容器，随后 docker exec  命令进入这个容器，接着通过 echo、cat 等命令向容器的标准输出中打印内容，最后通过 docker logs  查看日志。
实验是检验真理的唯一标准。您会发现，Experiement 1 中，查看日志会有日志；而 Experiement 2 中却找不到 echo、cat 等命令标准输出的日志内容。

Experiement 2 做完，瞬间毁三观，难道以上内容有差错？可以明确告诉您没有，那矛盾如何会存在？

欲知后事如何，关注「Allen 谈 Docker」系列，且听下回分解。

## 二、docker exec 与容器日志
[原文地址](http://guide.daocloud.io/dcs/docker-exec-9153970.html)

翻看 Docker 的历史，您会发现 Docker 一直在强调「Application」一词，Docker 也希望能为分布式应用提供容器化的解决方案。

从 Docker 化应用软件的生命周期来看，开发工作似乎位于 Docker 的构建之前，而后容器化的测试、部署与运维都与 Docker 容器息息相关。不得不说，Docker 思维下的应用软件，管理流程与传统场景有着很大的区别。

最大的区别当属 Docker 容器运行环境的封闭性。单一应用的运行，使得容器内部缺少功能丰富的服务。虽然用户可以通过 Docker 的层面，获取部分容器的信息，但是依然无法直接获悉应用内部的状态信息（虽然 Docker 倡导容器运行无状态的应用），比如应用容器内部持久化的日志文件、应用容器内部的临时存储等等。而这些信息在传统模式下，都可以较为轻易的获取。

为了缓解容器运行环境封闭性带来的使用障碍，Docker 提供了 docker exec  命令，方便用户在容器之外让容器执行指定的命令，以实现用户的需求。

今天你 **docker exec**  了吗？如果还没有的话，灵活穿越容器的感觉你值得拥有；如果有的话，那下面这些内容你不得不看。

### 1. 容器进程树与 docker exec
随着 Docker 的普及，相信越来越多的 Docker 爱好者已经意识到：
- Docker 容器其实就是若干进程构成；
- 而「一般情况下」这些进程呈现出「树状」关系；
- 容器内 pid 为 1 的进程为容器主进程；
- 一旦容器主进程退出，容器内所有进程退出。

其实，在 Docker 1.3 之前还不支持 docker exec  的时候，以上观点鲜有不妥，但是现在的情况却已然不同，且看下图：

![docker 进程示意图](http://7xi8kv.com5.z0.glb.qiniucdn.com/docker_exec-2.png)

### 2.docker exec 原理与容器日志
简述上图中 docker exec 的原理可以理解为以下两个步骤：
1. Docker Daemon 创建一个用户指定的进程 /bin/bash ，因此 /bin/bash  的父进程为 Docker Daemon；
2. Docker Daemon 为进程 P5 设定限制，如：加入容器主进程 P1 所在的隔离环境（namespaces），与其他进程一样受到资源限制（cgroups）等。

观察上图，分析原理，不难发现，容器内部的进程关系已然不是树。然而，为什么总是强调「树状「」关系呢？答案是：树状的继承关系，有利于容器管理。以上文《docker logs 实现剖析》中卖的关子「docker exec 的标准输出不会作为容器日志」为例，Docker Daemon 创建容器主进程时，负责接管主进程的标准输出，从而保证容器主进程下所有进程的标准输出被接管，然而 Docker Daemon 在新创建 docker exec  所需执行的进程时，后者的标准输出并未与容器主进程作关联，也并未被 Docker Daemon 特殊处理，故 docker exec  所执行进程的标准输出不会进入容器的日志文件中。

虽然 docker exec  所执行的进程也是容器的一部分，但是更准确的理解 Docker 容器的日志，可以是这样子的：Docker 容器的日志只负责应用本身的标准输出，不包括 docker exec  衍生进程的标准输出。

虽然本文标题与日志相关，但是几乎都在谈论 docker exec ，既然说到，不妨在这个屡试不爽的命令上提个醒：
1. docker exec  完成容器内外的交互，但希望完成大量标准输出时需谨慎；
2. 每次 docker exec ，Docker Daemon 均会记录一次 execID，切忌过于频繁。

从描述 docker exec  的原理到引入容器日志的一些小 trick，再加上前文的 docker logs 分析，相信很多人都会觉得对 Docker 容器的日志有了一个较为完整的认识。

然而，笔者却有不同的看法。应用 Docker 化之后，日志依然是一件非常棘手的事。笔者认为：容器内部日志文件 app.log  与 docker logs 依然无法满足传统模式下对日志的需求。

欲知后事如何，请关注「Allen 谈 Docker 系列」，且听下回《Docker 容器日志完结篇》分解。

## 三、Docker 容器日志的那些事儿
[原文地址](http://guide.daocloud.io/dcs/docker-9153973.html)

如果时光可以倒流，现实世界的每一步都可以分解到最小，记录下来，就是日志。万物即日志。

面对历史，审视日志，可以选择忘却，也可以选择铭记；经历过的，可以选择珍藏，同样也可以让它尘封。

Docker 容器又何尝不是？日志就像一根时间轴，你在或者不在，他都在那。有人对其善意，有人却对其随意。如若不信，可以回忆，自己是否善待 Docker 容器的日志。

### 1. 传统应用的日志
如若不是被过去伤得太深，踏入一个新的世界，应该还是会怀念过往的吧。新世界的「诱惑」与崭新的节奏，相信依旧无法掩盖旧世界的铅印。数十年岁月，应用的生命是如何在记录？
1. 很多人注重结果，对过程可能不闻不问，应用的日志可能随着标准输出（stdout）和标准错误（stderr）扬长而去，无法捕捉，无法定格，结果不如意时万分嗟叹；
2. 红袖添香，满腹经纶的才子也许会赋诗一首，书于内墙。故地重游，即唤起那良宵之夜。应用的日志也是如此，有心之人也会记录日志（赋诗一首），持久化至某处（书于内墙），便于他日查阅。
3. 随时随地都可以吟诗题字，古人走万里路，相信很难将所有的题诗悉数记忆。不管多远，如果记忆可以藏在一处便于日后美忆，方为上策。十年前，陈老师那一台电脑做到了；去年，大表姐的手机也帮她做到了。人生如此，遑论日志。日志日志，其实应用的日志也可以发往某处，集中处理。

### 2. Docker 时代的日志
Docker 时代的日志，步子并未跨得太大，毕竟安全第一。然而，不可否认发展的时代总有让你意想不到的亮点。

如果你是容器中的应用，哪怕你是始乱终弃，抑或是洒脱不羁，Docker 容器都会记录下你的点点滴滴，只要你对着标准输出标准错误说一句 「action」。（Docker 容器所有的标准输出标准错误都会被 Docker Daemon 接管。）

如果你是个阅尽人间无数，拳打南山，脚踢北海，四海流窜的 Docker 容器，你在北京的 One Night，兴许第二天在上海的你早已酒醒如初；第三天出差杭州的你，更是不记得昨天在上海住的是几星级宾馆。（Docker 容器本身理应尽量无状态，容器内应用持久化的日志则有状态，频繁迁移不宜容器日志管理。）

如果你有一部肾机，如果你继续支持大表姐。Docker 容器中的你，很容易将容器走南闯北的经历传至云端，以便他日传看。（Docker 容器的应用日志，如果自己发往集中的日志处理中心，则为上上策，易统一；问题是成本高，得有钱买肾机，还需统一化的标准。）

### 3. 获取 Docker 容器持久化日志
阅尽人间无数，却难忆点滴，想必并非君台所愿。梦醒时分，如何获悉北京 One Night 的一切，现授君些许技巧，从而轻易输送应用在 Docker 容器内部持久化的日志。

如果你已经熟知 docker logs 的原理，那么标准输出标准错误的那些事儿，在你看来自然不在话下。如果再加上一些 Dockerfile  的 CMD 知识，以下内容的理解自然也是水到渠成。

**目标**：通过标准输出，传递 Docker 容器内部的应用持久化日志文件。

**方法**：简单重构应用 Dockerfile  的 CMD 指令。

**问题假设**：原先应用 Dockerfile  的 CMD 指令为 CMD ["python", "app.py"] ，应用打印日志的路径为 /var/log/app.log 。

**具体实现**：

第一步：原先 Dockerfile  所在目录下，创建一个 run.sh  文件，文件内容为：
```ssh
#!/bin/bash
tail -F /var/log/app.log &
exec python app.py 
```
第二步：修改 Dockerfile ，删除原先的 CMD，替换为三个指令。
> 指令一：ADD run.sh / 
>
> 指令二：RUN chmod +x run.sh 
>
> 指令三：CMD ["./run.sh"] 

**原理剖析**：run.sh  中启动了一个后台进程，使用 tail 命令强制将 /var/log/app.log  的内容传输至标准输出，随后使用 exec 命令将 python app.py  作为容器的主进程运行。

示意图：

![修改后的进程](http://7xi8kv.com5.z0.glb.qiniucdn.com/docker%E6%97%A5%E5%BF%97.png)

新的纪元来临，技术革命带来巨大便利时，也许也需要稍微改变下原先的做法，Docker 容器的日志管理也是如此。毕竟 One Night in 北京，只需对 Docker 容器中安个镜头，对他说句 「action」，人力物力都省了，绝对比三里屯的一分钟轻松不少。

大概这样，成本应该还不算高吧。
